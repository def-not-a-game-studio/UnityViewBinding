namespace Editor
{
    using System.Text;
    using System.Text.RegularExpressions;
    using UnityEditor;
    using UnityEngine;
    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;
    using UnityEditor.SceneManagement;

    [InitializeOnLoad]
    public class ViewBinderAssetProcessor
    {
        private const string ViewBindingAssetSuffix = ".view.prefab";
        private const string PartGroupPrefix = "---";
        private const string PartHeaderPrefix = "!u!";
        private const string GameObjectId = "1";
        private const string MonoBehaviourId = "114";
        private const string Indentation = "  ";
        private const string ComponentPrefix = "  - component: {fileID: ";
        private const string ScriptPrefix = " {fileID: 11500000, guid:";
        private const string ScriptSuffix = ", type: 3}";

        static ViewBinderAssetProcessor()
        {
            PrefabStage.prefabStageClosing += OnPrefabUpdated;
        }

        private static void OnPrefabUpdated(PrefabStage prefabStage)
        {
            if (!prefabStage.assetPath.ToLowerInvariant().EndsWith(ViewBindingAssetSuffix)) return;

            try
            {
                ProcessAsset(prefabStage.assetPath);
            }
            catch (Exception e)
            {
                Debug.LogError(e);
            }
            finally
            {
                prefabStage.ClearDirtiness();
            }
        }

        private static void ProcessAsset(string path)
        {
            ReadAssetYaml(path);
        }

        private static string Normalize(string inStr)
        {
            return Regex.Replace(inStr, @"[^\w]", "", RegexOptions.None, TimeSpan.FromSeconds(.5));
        }

        private static void ReadAssetYaml(string path)
        {
            var assetName = Path.GetFileNameWithoutExtension(path);
            var parsedName = $"{Normalize(assetName)}Binding";
            var groups = ParseYamlIntoGroups(path);

            FindProperties(groups, assetName, parsedName, out var properties, out var imports, out var propMappings);
            WriteCSharpFile(imports, parsedName, properties);
            MaybePatchYaml(path, groups, parsedName, propMappings);
        }

        private static void MaybePatchYaml(string path, Dictionary<PartDefinition, List<PartProperty>> groups, string parsedName,
            SortedDictionary<string, string> propMappings)
        {
            var customMonoGuid = FindCustomMonoGuid(groups, parsedName);
            if (customMonoGuid == default) return;
            ApplyNewPropertiesValues(path, customMonoGuid, propMappings);
        }

        private static void WriteCSharpFile(HashSet<string> imports, string parsedName, HashSet<string> properties)
        {
            var stringBuilder = new StringBuilder();
            stringBuilder.Append(@$"// This class was automatically generated by UnityViewBinding. Do not change.

using UnityEngine;
{string.Join(";\n", imports)};

public partial class {parsedName} 
{{

{string.Join(";\n", properties)};

}}
");
            var scriptPath = $"Assets/Scripts/UnityViewBinding/{parsedName}.cs";
            if (!AssetDatabase.IsValidFolder("Assets/Scripts/UnityViewBinding"))
            {
                AssetDatabase.CreateFolder("Assets/Scripts", "UnityViewBinding");
            }

            File.WriteAllText(scriptPath, stringBuilder.ToString());
            AssetDatabase.Refresh();
        }

        private static string FindCustomMonoGuid(Dictionary<PartDefinition, List<PartProperty>> groups,
            string parsedName)
        {
            // search through all monos if there's one matching our parsed name
            // meaning that's the one we must edit
            string customMonoGuid = default;
            foreach (var (key, value) in groups)
            {
                if (key.PartType != MonoBehaviourId)
                    continue;

                var script = value
                    .First(it => it.PropertyName == "m_Script")
                    .PropertyValue;
                var guid = script.Substring(ScriptPrefix.Length,
                    script.IndexOf(ScriptSuffix, StringComparison.Ordinal) - ScriptPrefix.Length).Trim();
                var monoPath = AssetDatabase.GUIDToAssetPath(guid);
                var monoName = Path.GetFileNameWithoutExtension(monoPath);

                if (monoName != parsedName)
                    continue;

                customMonoGuid = guid;
                break;
            }

            return customMonoGuid;
        }

        private static void ApplyNewPropertiesValues(string path, string customMonoGuid, SortedDictionary<string, string> propMappings)
        {
            const string customMarkerStart = "--- !vb SectionStart";
            const string customMarkerEnd = "--- !vb SectionEnd";
            const string desiredLastLine = "  m_EditorClassIdentifier: ";
            var scriptLine = $"  m_Script: {{fileID: 11500000, guid: {customMonoGuid}, type: 3}}";

            var assetFile = File.ReadAllLines(path).ToList();
            var scriptLineIndex = assetFile.IndexOf(scriptLine);
            var sectionStartIndex = assetFile.IndexOf(customMarkerStart, scriptLineIndex);
            var sectionEndIndex = assetFile.IndexOf(customMarkerEnd, scriptLineIndex);
            var lastLineIndex = assetFile.IndexOf(desiredLastLine, scriptLineIndex);

            if (sectionStartIndex > 0 && sectionEndIndex > 0)
            {
                var count = sectionEndIndex - sectionStartIndex;
                assetFile.RemoveRange(++sectionStartIndex, count - 1);

                foreach (var (key, value) in propMappings)
                {
                    var line = $"  {key}: {{fileID: {value}}}";
                    assetFile.Insert(sectionStartIndex, line);
                }
            }
            else
            {
                assetFile.Insert(++lastLineIndex, customMarkerStart);
                foreach (var (key, value) in propMappings)
                {
                    var line = $"  {key}: {{fileID: {value}}}";
                    assetFile.Insert(++lastLineIndex, line);
                }

                assetFile.Insert(++lastLineIndex, customMarkerEnd);
            }

            File.WriteAllLines(path, assetFile);
        }

        private static void FindProperties(
            Dictionary<PartDefinition, List<PartProperty>> groups,
            string assetName,
            string parsedClassName,
            out HashSet<string> properties,
            out HashSet<string> imports,
            out SortedDictionary<string, string> propMappings)
        {
            var ids = new HashSet<string>();
            imports = new HashSet<string>();
            properties = new HashSet<string>();
            propMappings = new SortedDictionary<string, string>();

            foreach (var (partDefinition, partProperties) in groups)
            {
                if (partDefinition.PartType != GameObjectId)
                    continue;

                var name = partProperties.First(it => it.PropertyName == "m_Name").PropertyValue;
                if (name == assetName)
                {
                    name = "Root";
                }

                name = Normalize(name);

                var monoScriptReferences = FindMonoScripts(partProperties, groups);
                foreach (var monoScriptReference in monoScriptReferences)
                {
                    var scriptPath = AssetDatabase.GUIDToAssetPath(monoScriptReference.AssetGuid);
                    var behaviourName = Path.GetFileNameWithoutExtension(scriptPath);

                    if (behaviourName == parsedClassName)
                        continue;

                    var behaviourNamespace =
                        File.ReadAllLines(scriptPath).FirstOrDefault(it => it.StartsWith("namespace"))?["namespace".Length..]?.Trim();
                    var propName = $"{name}_{behaviourName}";
                    var property = $"    [SerializeField] public {behaviourName} {propName}";

                    // ReSharper disable once CanSimplifySetAddingWithSingleCall
                    if (ids.Contains(propName))
                    {
                        throw new InvalidDataException(
                            $"Element id {propName} is already defined. GameObjects names are treated as Ids");
                    }

                    ids.Add(propName);
                    properties.Add(property);
                    if (behaviourNamespace is not null)
                    {
                        imports.Add($"using {behaviourNamespace}");
                    }

                    propMappings.Add(propName, monoScriptReference.FileId);
                }
            }
        }

        private static Dictionary<PartDefinition, List<PartProperty>> ParseYamlIntoGroups(string path)
        {
            var groupsRaw = File.ReadAllText(path).Split(PartGroupPrefix).ToList();
            var groups = new Dictionary<PartDefinition, List<PartProperty>>();

            foreach (var group in groupsRaw)
            {
                PartDefinition partDefinition = default;
                var partProperties = new List<PartProperty>();

                foreach (var line in group.Split('\n'))
                {
                    // discard file headers
                    if (line.StartsWith('%')) continue;

                    // Group (MonoBehaviour/GameObject/Transform/etc) heading
                    // --- !u!1 &1753319643823132500
                    if (line.Trim().StartsWith(PartHeaderPrefix))
                    {
                        partDefinition = new PartDefinition
                        {
                            PartType = line[4..].Split('&')[0].Trim(),
                            FileId = line[(line.IndexOf('&') + 1)..].Trim(),
                        };
                    }

                    // looking first for a single indentation property
                    if (line.StartsWith($"{Indentation}"))
                    {
                        var colonIndex = line.IndexOf(':');
                        if (line.StartsWith(ComponentPrefix))
                        {
                            var fileID = line.Substring(ComponentPrefix.Length,
                                line.IndexOf('}') - ComponentPrefix.Length).Trim();
                            partProperties.Add(new PartComponent
                            {
                                FileId = fileID
                            });
                        }
                        else
                        {
                            partProperties.Add(new()
                            {
                                PropertyName = line[..colonIndex].Trim(),
                                PropertyValue = line[(colonIndex + 1)..].Trim(),
                            });
                        }
                    }
                }

                if (partDefinition == null) continue;

                groups[partDefinition] = partProperties;
            }

            return groups;
        }

        /// <summary>
        /// Returns tuple of (fileId, guid)
        /// </summary>
        /// <param name="partProperties"></param>
        /// <param name="groups"></param>
        /// <returns></returns>
        private static List<MonoScriptReference> FindMonoScripts(List<PartProperty> partProperties,
            Dictionary<PartDefinition, List<PartProperty>> groups)
        {
            var monoReferences = new List<MonoScriptReference>();
            // a GameObject in the yaml has a field called "components"
            // which points to another component in the yaml using the fileID
            var components = partProperties.OfType<PartComponent>().Select(it => it.FileId).ToList();

            foreach (var componentFileId in components)
            {
                var component = groups.First(it => it.Key.FileId == componentFileId);

                if (component.Key.PartType == MonoBehaviourId)
                {
                    var script = component.Value
                        .First(it => it.PropertyName == "m_Script")
                        .PropertyValue;
                    var monoScript = new MonoScriptReference
                    {
                        FileId = component.Key.FileId.Trim(),
                        AssetGuid = script.Substring(ScriptPrefix.Length,
                            script.IndexOf(ScriptSuffix, StringComparison.Ordinal) - ScriptPrefix.Length).Trim(),
                    };
                    monoReferences.Add(monoScript);
                }
            }

            return monoReferences;
        }
    }
}

public class PartDefinition
{
    public string PartType;
    public string FileId;
}

public class PartProperty
{
    public string PropertyName;
    public string PropertyValue;
}

public class PartComponent : PartProperty
{
    // - component: {fileID: n}
    public string FileId;
}

public class MonoScriptReference
{
    public string FileId;
    public string AssetGuid;
}